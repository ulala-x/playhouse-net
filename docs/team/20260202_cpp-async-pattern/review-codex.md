# Codex Review: C++ Async Pattern Selection

## 요약
**1M+ TPS, 낮은 지연, 메모리 효율**을 최우선으로 둔 게임 서버라면 **C++20 Coroutine(특히 ASIO/네이티브 연계)**이 더 안전한 선택입니다.

## 질문별 답변

### 1. C++ 고성능 게임 서버에서 Coroutine vs Fiber 추천

**성능/메모리/스케일 기준이면 Coroutine 추천:**
- Stackless + 낮은 메모리 풋프린트는 동시 접속 수가 늘수록 이점이 커짐
- ASIO가 코루틴 친화적이라 IO 경로도 정돈됨

**개발 편의/기존 동기 라이브러리 활용이 최우선이면 Fiber 고려 가능:**
- 동기 코드처럼 쓸 수 있는 건 큰 장점
- 일정 규모까지는 충분히 성능이 나올 수 있음

### 2. 1M+ TPS 목표 시 Coroutine이 맞는 선택인가요?

**네, 우선순위가 "TPS/지연/메모리"라면 Coroutine이 더 맞습니다.**
- 1M+ TPS 구간에서는 스케줄링/컨텍스트 스위칭 오버헤드가 티가 남
- Fiber의 stackful 모델은 캐시/메모리 압박이 커지고, 프리엠션 정책이 복잡해질수록 비용 증가
- Coroutine은 "co_await 전염"이라는 구조적 비용이 있지만, 성능 목표가 매우 높다면 그 비용을 감수할 가치가 큼

### 3. 다른 고려사항

- **디버깅/툴링**: Coroutine은 스택 트레이스가 직관적이지 않고 디버깅이 까다로울 수 있음. 팀 숙련도가 중요
- **스케줄러 설계**: Coroutine 성능은 결국 스케줄러 품질에 달려 있음. 타이머/IO/워크스틸링/배압(backpressure) 정책이 병목을 좌우
- **라이브러리 호환성**: 기존 동기 API를 많이 써야 한다면 coroutine 래핑 비용이 커질 수 있음. 핵심 경로만 coroutine화하고 나머지는 별도 풀로 분리하는 혼합 설계도 가능
- **메모리 파편화/할당 전략**: Coroutine frame 할당 풀링은 성능에 큰 영향
- **테스트/관측성**: 고TPS에서는 이벤트 추적/관측 시스템이 성능에 영향. 최소 오버헤드 프로파일링 전략 필요

## 최종 추천

- **PlayHouse C++ 서버/커넥터: Coroutine 우선** - 이미 .NET 모델과 유사하고, 높은 TPS 목표에 유리
- **Fiber는 "생산성/호환성"을 강하게 요구하는 모듈 한정**으로 고려하는 게 현실적

# [계획서] 기아 감지 워커 풀을 이용한 10,000 CCU 성능 최적화

## 1. 개요 (Overview)
단순한 부하 기반 확장의 비효율성을 극복하고, 기존 워커들이 '긴 대기(Long Wait)' 상태에 빠져 전체 처리량이 저하될 때만 워커를 추가 투입하는 **기아 감지 기반 확장(Starvation-based Scaling)** 아키텍처를 도입함.

## 2. 핵심 설계 변경 (Core Design)

### A. 워커 상태 세분화
- **Idle (유휴):** 작업을 기다리며 큐를 바라보고 있는 상태.
- **Busy (작동):** 로직을 실행 중이거나 `await` 대기 중인 상태.

### B. 기아 상태 감지 로직 (Starvation Detection)
- **조건:** 큐에 작업이 존재함에도 불구하고, 일정 시간(예: 100ms) 동안 유휴 워커가 발생하지 않는 경우.
- **판단:** 기존 워커들이 IO 대기 또는 긴 비동기 작업에 묶여 있어 새로운 메시지를 처리하지 못하고 있다고 간주.

### C. 신중한 확장 (Conservative Expansion)
- **방식:** 기아 상태가 지속될 때만 `MaxTaskPoolSize` 범위 내에서 워커를 점진적으로 추가.
- **이점:** 일시적인 네트워크 폭주(Burst) 시 불필요한 Task 생성 오버헤드를 원천 차단하고, 실제 병목 상황에서만 자원을 투입.

## 3. 구현 세부 사항

### GlobalTaskPool 고도화
- `_idleWorkerCount`를 정밀하게 추적.
- 마지막으로 워커가 유휴 상태가 된 시점(`_lastIdleTimestamp`)을 기록.
- `Post()` 호출 시 큐 정체 시간과 유휴 워커 부재 시간을 비교하여 확장 여부 결정.

---

## 4. 기대 효과
- **불필요한 오버헤드 제거:** 10,000명의 폭주 시에도 실제 로직 처리 속도가 빠르면 워커 수를 최적으로(예: 100개) 유지.
- **병목 구간 대응:** DB 조회나 외부 API 호출 등으로 워커들이 묶였을 때만 유연하게 확장하여 서비스 가용성 유지.